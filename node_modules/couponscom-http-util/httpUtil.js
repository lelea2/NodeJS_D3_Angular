/*jshint maxparams:3, maxdepth: 5, maxstatements: 40, maxcomplexity: 10 */
/**
 * Util function for application: get current request object, parsing URL...
 * Usage:
 *      var httpUtil = require('couponscom-http-util');
 */

'use strict';

var useragent = require('express-useragent'),
    querystring = require('querystring'),
    HTTPStatus = require('http-status'),
    get_ip = require('ipware')(__dirname + '/config/ipware.json').get_ip,
    nconf = require('couponscom-config-chain-manager'),
    cidr = require('ipfunctions'),
    logger = require('couponscom-logger'),
    httpUtil_config = nconf.getData({
        name: 'httpUtil',
        filename: __dirname + '/config/httpUtil.json'
    });

//GLOBAL variable for currentRequest
global.CURRENTREQUEST; //Current request is initiated as global object, it will change when util gets re-initialized

module.exports = (function () {

    /**
     * Initialize request object, called in requestStart()
     * @method initialize
     */
    function initialize () {
        return function (req, res, next) {
            //To support case-insensitive querystring in express, currently, we have to to this in middleware,
            //quite simple, but still, painful!
            for (var key in req.query) {
                req.query[key.toLowerCase()] = req.query[key];
            }
            global.CURRENTREQUEST = req;
            next();
        };
    }

    /**
     * Get current route based on express request object (for routing)
     * Note: we should only used this for getting route, and tie it the lowest level of middleware
     * Referenced from http://stackoverflow.com/questions/19460481/express-js-get-route-definition-in-middleware
     * @method getCurrentRoute
     */
    function getCurrentRoute(req) {
        var currentRoute = '';
        try {
            currentRoute = req.route.path || '';
        } catch(ex) {
            logger.error(__filename + ': Error while getting current express route; ex=' + ex);
        }
        return currentRoute;
    }

    /**
     * Get current URI path (including parameter following)
     * @method getCurrentURI
     */
    function getCurrentURI (currReq) {
        var req = currReq || global.CURRENTREQUEST;
        return req.originalUrl;
    }

    /**
     * Get current host name from "Host" header field
     * @method getCurrentHost
     */
    function getCurrentHost (currReq) {
        var req = currReq || global.CURRENTREQUEST;
        return req.hostname;
    }

    /**
     * Get current URI path without parameter
     * @method: getCurrentPath
     */
    function getCurrentPath (currReq) {
        var req = currReq || global.CURRENTREQUEST;
        return req.path;
    }

    /**
     * Get Referrer url
     * @method getReferrerURL
     */
    function getReferrerURL (currReq) {
        var req = currReq || global.CURRENTREQUEST,
            referrer = '';
        try {
            referrer = req.headers.referer;
        } catch (ex) {
            //Should not process anything
        }
        return referrer;
    }

    /**
     * Function to get current protocol
     * @method getCurrentProtocol
     */
    function getCurrentProtocol (currReq) {
        try {
            var protocol = currReq.protocol;

            if(protocol === 'http' && process.env.NODE_ENV !== 'development' && currReq.headers['x-ci-secure'] === '1') {
                protocol = 'https';
            }

            return protocol;
        } catch(ex) {
            return '';
        }
    }

    /**
     * Function to get the whole query string in URL
     * @method getQueryString
     */
    function getQueryString (currReq) {
        try {
            var result = querystring.stringify(currReq.query);
            return result;
        } catch(ex) {
            return '';
        }
    }

    /**
     * Get specific values of a query parameter
     * @method getQueryValue
     * @param {string} paramName to get specific value
     * @param {string} currReq optional current URL
     */
    function getQueryValue (paramName, currReq) {
        var req = currReq || global.CURRENTREQUEST,
            value = '',
            param = paramName.toLowerCase();

        try {
            value = (req.query[paramName] || req.params[paramName] || req.query[param] || req.params[param] || req.body[paramName] || '');
        } catch (ex) {
            //should not process to get req obj property
        }
        return value;
    }

    /**
     * Update query string parameter, for replace or adding parameter to url
     * @method updateQueryStringParameter
     */
    function updateQueryStringParameter (url, key, value) {
        var keyvalue = new RegExp('([?|&])' + key + '=.*?(&|#|$)', 'i'),
            result;
        if (url.match(keyvalue)) {
            result = url.replace(keyvalue, '$1' + key + '=' + value + '$2');
        } else {
            var hash =  '',
                separator = url.indexOf('?') !== -1 ? '&' : '?';
            if( url.indexOf('#') !== -1 ){
                hash = url.replace(/.*#/, '#');
                url = url.replace(/#.*/, '');
            }
            result = url + separator + key + '=' + value + hash;
        }
        return result;
    }

    /**
     * Function that set request body data with specific key
     * @method setReqBodyData
     */
    function setReqBodyData(key, value, currReq) {
        var req = currReq || global.CURRENTREQUEST,
            pageContextData;
        req.body = req.body || {};
        pageContextData = req.body.pageContextData || {};
        pageContextData[key] = value;

        req.body.pageContextData = pageContextData;
    }

    /**
     * Function that get request body data with specific key
     * @method getReqBodyData
     */
    function getReqBodyData(key, currReq) {
        var req = currReq || global.CURRENTREQUEST,
            value = '';
        try {
            var pageContextData = req.body.pageContextData || {};
            value = pageContextData[key] || '';
        } catch(ex) {}
        return value;
    }

    /**
     * Function to get client IP for an incoming request
     * @method getClientIP
     */
    function getClientIP(currReq) {
        try {
            var reqHeaders = currReq.headers,
                ipInfo = get_ip(currReq);
            //console.log('clientip' + reqHeaders['client-ip']);
            return reqHeaders['client-ip'] || ipInfo.clientIp;
        } catch(ex) {
            logger.warn(__filename + ': Empty request in method getClientIP()');
        }
        return '';
    }

    /**
     * Helper function to detecting useragent and return true if we are in mobile mode
     * @method isMobile
     */
    function isMobile(currReq) {
        var req = currReq;
        try {
            var userAgent = (req.headers['user-agent']) ? (useragent.parse(req.headers['user-agent'])) : '';
            if ((userAgent !== '') && (userAgent.isMobile)) {
                return true;
            }
        } catch(ex) {
            logger.warn(__filename + ': Empty request in method isMobile()');
        }
        return false;
    }

    /**
     * Determines if the given IP address falls within the given CIDR
     * block. Logic carry over from zend stack
     * @method ipInCidrBlock
     * @param $ip IP address to test, as a dotted-quad string (e.g., '1.2.3.4')
     * @param $cidr CIDR block, string of form 'a.b.c.d/n', (e.g., '1.2.3.4/8')
     *
     * @returns boolean
     */
    function ipInCidrBlock(clientIp, cidrStr) {
        var arr = cidrStr.split('/'),
            ip = cidr.ip2long(clientIp),
            subnet = cidr.ip2long(arr[0]),
            mask = -1 << (32 - arr[1]);
        subnet &= mask;
        return (ip & mask) === subnet;
    }

    /**
     * Helper function checking if clientIP is trusted
     * @method isTrustedIP
     */
    function isTrustedIP(currReq) {
        var clientIP = getClientIP(currReq),
            trustedIP = httpUtil_config.trustedIP || /* istanbul ignore next */ [];

        logger.info(__filename + ': Checking trusted IP with clientIP=' + clientIP);

        for(var i = 0; i < trustedIP.length; i++) {
            if (ipInCidrBlock(clientIP, trustedIP[i])) {
                logger.info(__filename + ': clientIP=' + clientIP + ': is trusted in Cidr block');
                return true;
            }
        }
        logger.info(__filename + ': clientIP ' + clientIP + ': is not trusted');
        return false;
    }

    /**
     * Helper function check in clientIP is private
     * @method isPrivateIP
     */
    function isPrivateIP(currReq) {
        var clientIP = getClientIP(currReq),
            privateIP = httpUtil_config.privateIP || /* istanbul ignore next */ [];

        logger.info(__filename + ': Checking private IP with clientIP=' + clientIP);

        for(var i = 0; i < privateIP.length; i++) {
            if (ipInCidrBlock(clientIP, privateIP[i])) {
                logger.info(__filename + ': clientIP=' + clientIP + ': is private in Cidr block');
                return true;
            }
        }
        logger.info(__filename + ': clientIP ' + clientIP + ': is not private');
        return false;
    }

    return {
        initialize: initialize,
        getCurrentRoute: getCurrentRoute,
        getCurrentURI: getCurrentURI,
        getCurrentHost: getCurrentHost,
        getCurrentPath: getCurrentPath,
        getCurrentProtocol: getCurrentProtocol,
        getReferrerURL: getReferrerURL,
        getQueryString: getQueryString,
        getQueryValue: getQueryValue,
        getClientIP: getClientIP,
        setReqBodyData: setReqBodyData,
        getReqBodyData: getReqBodyData,
        updateQueryStringParameter: updateQueryStringParameter,
        isTrustedIP: isTrustedIP,
        isPrivateIP: isPrivateIP,
        isMobile: isMobile,
        HTTPStatus: HTTPStatus
    };

}());
